# Database
**MARIADB로 진행**
## DATABASE란
> DATABASE는 어느 한 조직의 여러 응용시스템 들이 공용할 수 있도록 통합되고 저장된 운영 데이터의 집합을 말하며 자료의 집중화를 통해서 중복된 자료를 최소화 시켜 다양한 응용분야를 효과적으로 컴퓨터에서 지원할 수 있도록 체계적으로 구성되 자료의 집합이다.
## DATABASE의 특성
 1) 실시간 접근성 : 수시적이고 비정형적인 질의에 대하여 실시간 처리로 응답할 수 있다.
 2) 지속적 변화 : 새로운데이터의 삽입, 삭제, 갱신을 통해 현재의 정확한 자료를 유지하면서 변화한다.
 3) 동시 공용 : 다수의 사용자가 동시에 원하는 데이터베이스에 접근하여 이용할 수 있다.
 4) 내용에 의한 참조 : 데이터 참조는 데이터베이스에 저장된 레코드들의 위치나 주소에 의해서가 아니라 사용자가 요구하는 데이터의 내용 즉 값에따라 참조된다.
## 데이터 '무결성'과 '일관성'
* 무결성 : 무결성은 정밀성,정확성과 일맥상통하다. DB에 저장된 데이터값과 그것이 표현하는 현실 세계의 실제값이 일치하는 정확성을 의미한다. 
ex ) 

| 전화번호 1 | 전화번호2 | 전화번호3 |
|---|:---:|---| 
| 010-1111-1111 | 010-1111-1111 | 010-1111-1111 |

전화번호1,2,3 이렇게 똑같은 번호가 저장되어있고 같은 사람이 사용하는 번호이다. 그런데 기존에 사용하던 번호를 바꾸게 되어 전화번호도 010-2222-2222로 변경했다

| 전화번호 1 | 전화번호2 | 전화번호3 |
|---|:---:|---| 
| 010-2222-2222 | 010-2222-2222 | 010-1111-1111 |

전화번호1,2는 바뀌었는데 3은 그대로이다 이상태를 **'일관성 이 깨졌다'** 라고 이야기 한다. 데이터가 일치되어야 하는데 불일치가 된것이고 전체적으로 확정해서 보게되면 무결성이 깨진것이다.
**데이터 베이스의 가장 큰 목표는 '데이터 무결성'을 높이는 것** 이다
 ### 데이터 정합성과 무결성
 * 데이터 정합성
  > 어떤 데이터들의 값이 서로 일치하는 상황.
  * **정합성은 데이터가 서로 모순이 없이 일관되게 일치** 해야 한다는 의미이다. 외래키 제약조건이라고도 한다
 * 데이터 무결성
  > 데이터가 현실과 정확하게 일치하는지 보는 것이다.
  > 참조 무결성은 외래키의 개념과 관련된다. 참조 무결성 규칙은 모든 외래키 값은 두가지 상태 가운데 하나에만 속함을 규정한다. 일반적 상태는 외래키 값이 데이터베이스의 특정 테이블의 기본 키 값을 참조하는 것이다. 이는 비즈니스 규칙에따라 달라질수 있으며 외래키값은 빈값을 허용한다.
 ## 키(key) = 식별자(identifier)
 > 튜플을 유일하게 식별할 수 있는 속성 집합을 그 릴레이션의 키라고 하며 튜플을 검색하거나 정렬할떄 튜플들을 서로 구분할 수 있는 기준이 되는 속성을 말한다.
  ### 키의 특성
  > 키의 특성을 **유일성과 최소성** 2가지가 있는데 유일성은 하나의 키 값으로 하나의 튜플만을 유일하게 식별할 수 있는것이고 최소성은 키를 구성하는 속성 하나만 제외시켜도 유일성이 꺠지도록 꼭 필요한 최소의 속성이 구성되는것을 말한다.
  ### 키의 종류
   1) 슈퍼키 
    > 슈퍼키는 튜플을 유일하게 구분하기 위하여 한개 이상의 속성들의 집합으로 이루어진 키를 말하고 유일성은 만족시키지만 최소성은 만족시키지 못한다
   
   | 학번 | 성명 | 주민번호 | 학과 |
   |---|---|---|---|
   | 100 | 백번이 | 100100-1001001 | 전자 |
   | 200 | 이백번이 | 200200-2002002 | 컴퓨터 |
   | 300 | 삼백번이 | 300300-3003003 | 경영 |
   
   위의 학생 테이블에서 유일하게 식별할 수 있는 컬럼은 학번과 주민번호이다. 성명,학과는 중복값있을수 있기에 유일성 만족x. => 학번과 주민번호가 슈퍼키이다. 그리고 유일성만 만족시키면 되기 때문에 {학번,주민번호}, {학번,성명}(물론 다른것들 추가되도 상관 x) 이렇게 두개의 속성으로 묶어도 슈퍼키라고 할수 있다. 근데 굳이 학번하나로 충분히 구분해 낼수 있는데 다른값이 들어갈 필요성은 크게 없고 최소성또한 만족시키지 못한다.
 * 정리하자면 슈퍼키는 유일하게 식볋 낼수 있는 속성이 있다면 그 속성들은 모두 슈퍼키가 될수 있다. '학번'만 가지고 유일하게 식별 할 수 있다고 한다면 학번 이라는 속성은 최소성과 유일성 모두 만족이 된다. 근데 {학번,성명} 이렇게 2개의 속성을 넣어버리면 학번 하나만 가지고도 식별할 수 있는데 굳이 성명이라는 속성이 더 있기에 최소성은 만족을 못하는 것이다.
  2) 후보키
   > 후보키는 유일하게 구분할 수 있는 최소 슈퍼키를 의미하며 슈퍼키와는 다르게 후보키는 최소성과 유일성 모두 만족한다. 하나의 테이블에 속하는 모든 튜플들은 중복된 값을 가질수 없으므로 모든 테이블은 반드시 하나 이의 후보키를 갖는다.
   
   | 학번 | 성명 | 주민번호 | 학과 |
   |---|---|---|---|
   | 100 | 백번이 | 100100-1001001 | 전자 |
   | 200 | 이백번이 | 200200-2002002 | 컴퓨터 |
   | 300 | 삼백번이 | 300300-3003003 | 경영 |
   
   위 학생테이블에서 유일학 ㅔ식별할 수있는 속성은 학번과 주민번호이므로 후보키는 학번과 주민번호이다. {학번,주민번호} 이렇게 2개의 속성으로 묶고 보면 누가 어떤 학과인지 파악할수 있고 이오같이 2개 이상의 속성으로 키를 구성한것을 '복합키'라고 한다(물론 주민번호를 pk로 사용하면 안된다.)
   
  3) 기본키 (Primary key) PK , 주식별자, 주키
  > 기본키는 유일하게 식별해 낼 수 있는 속성중 후보키가 되는것 중에서 선정된 키이다. 기본키는 무조건 존재 해야하며 중복값이나 널을 허용하지 않는다.
  
  | 학번 | 성명 | 주민번호 | 학과 |
   |---|---|---|---|
   | 100 | 백번이 | 100100-1001001 | 전자 |
   | 200 | 이백번이 | 200200-2002002 | 컴퓨터 |
   | 300 | 삼백번이 | 300300-3003003 | 경영 |
   
   위의 학생 테이블은 학번과 주민 번호가 슈퍼키와 후보키를 모두 만족하지만 주민번호는 애초에 변경 가능성 있는 속성이고 가능성이 희박하더라도 민감한 개인정보이기 때문에 pk로 사용하기 적절치 않다. 따라서 학번을 pk로 설정하는 것이 맞다.
  
   | 학번 | 과목코드 | 학점 | 학과 |
   |---|---|---|---|
   | 100 | A001 | A+ | 전자 |
   | 200 | A001 | B | 컴퓨터 |
   | 200 | B002 | B | 컴퓨터 |
   | 300 | B002 | C | 경영 |
   | 300 | C003 | A+ | 경영 | 
   
   위의 <수강> 테이블은 모든 항목이 서로 중복되기 때문에 2개의 속성을 후보키로 구성해서 사용해야한다.{학번, 과목코드} 이렇게 묶어서 사용하면 어떤학생이 어떤 과목에서 몇점을 받았는지 파악 가능하다.
   
  4) 대체키
  > 대체키는 하나의 테이블에 존재하는 후보키들 중에서 기본키를 제외한 나머지 후보키를 말한다. 즉 후보키 - 기본키 = 대체키 이렇게 되고 보조키 라고도 한다.
  5) 외래키
  > 외래키는 어떤 테이블의 pk값과 일치함을 요구하는 다른 테이블의 한 속성(컬럼)을 의미하고 **외래키를 포함하는 테이블이 참조하는 테이블이 되고 대응되는 기본키를 포함하는 테이블이 피참조 테이블이 된다** 또 RDBM에서 한 테이블의 외래키는 피참조 테이블의 기본키와 대응되어 테이블 간의 참조관계를 표현하는데 사용되는 중요한 속성이다.
## 무결성 제약조건
 * 무결성의 개념 : 무결성은 데이터베이스에 저장된 데이터 값과 그것이 표현하는 현실세계의 값이 일치하는 정확성을 의미한다
 * 무결성 제약 조건 3가지
 > 무결성 제약조건은 크게 개체 무결성, 참조무결성, 도메인무결성 이렇게 3개가 있다
  1) 개체 무결성
  > 개체 무결성은 기본키와 관련된 제약조건으로 한 테이블의 기본키를 구성하는 어떠한 속성도 절대 널 값이나 중복값은 가질 수 없다는 제약 조건이다.
  
   | 학번 | 성명 | 주민번호 | 학과 |
   |---|---|---|---|
   | 100 | 백번이 | 100100-1001001 | 전자 |
   | 200 | 이백번이 | 200200-2002002 | 컴퓨터 |
   | 300 | 삼백번이 | 300300-3003003 | 경영 |
   |     | 사색번이 | 400400-4004004 | 디자인 |
   
   | 학번 | 성명 | 주민번호 | 학과 |
   |---|---|---|---|
   | 100 | 백번이 | 100100-1001001 | 전자 |
   | 200 | 이백번이 | 200200-2002002 | 컴퓨터 |
   | 300 | 삼백번이 | 300300-3003003 | 경영 |
   | 300 | 사색번이 | 400400-4004004 | 디자인 |
   
   **위의 테이블의 기본키(pk)인 학번 속성이 비어있거나 = null이거나, 학번이 중복되면 '개체무결성 원칙'에 위배 되었다고 하며 개체무결성 원칙을 지키기 위해선 NUll 대신 다른 튜플과 구별되는 값으로 적용해줘야 한다.**
   
   2) 도메인 무결성
   > 도메인무결성은 주어진 속성의 값이 그 속성이 정의된 도메인에 속한 값이어야 한다는 제약조건이다.
   
   | 학번 | 성명 | 학년 | 학과 |
   |---|---|---|---|
   | 100 | 백번이 | 1| 전자 |
   | 200 | 이백번이 | 2 | 컴퓨터 |
   | 300 | 삼백번이 | 3 | 경영 |
   | 300 | 사색번이 | 5 | 디자인 |
   
   위의 학생 테이블은 4년제 대학교라고 가정했을때 학년은 5학년이 되어선 안된다 도메인이 들어올수 있는 범위는 1~4까지의 범위여야 한다.(사실 도메인의 정의가 감이 안잡혔는데 실제의 어떤 값의 조건 정도로 파악하면 될듯하다 말로 설명하기 애매하게 감이 잡힘) 
   
   3) 참조 무결성
   > 참조무결성은 외래키와 관련된 제약조건으로 테이블1에 저장된 튜플이 테이블2에 있는 튜플을 참고하려면 참조되는 튜플이 반드시 테이블2에 존재해야 한다는 제약조건이다. 테이블은 참조할 수 없는 외래키 값을 가질수 없으며 외래키 값은 피참조 테이블의 기본값으로 존재해야 한다. 외래키의 속성들은 피참조 테이블의 기본키와 도메인이 동일해야하고 외래키의 속성 갯수와 피참조 테이블의 기본키 속성 갯수는 같아야 한다.

## SQL
> SQL은 IBM연구소에서 개발한 SEQUEL에서 연유한 것이고 관계대수와 관계해석을 기초로한 고급 데이터 언어이다.
 ### SQL의 종류
 <img src = "https://img1.daumcdn.net/thumb/R800x0/?scode=mtistory2&fname=https%3A%2F%2Ft1.daumcdn.net%2Fcfile%2Ftistory%2F210F5B4A55D45A950D"/>
  #### DDL (데이터 정의어)
  > DDL은 DBMS에서 사용할 데이터베이스의 정의 및 변경을 위해서 사용하는 언어이며 외부스키마 명세를 정의하고 스키마에 사용되는 제약 조건 명세를 정의하고 DB의 논리적 데이터 구조와 물리적 데이터 구조 및 구조간의 사상을 정의한다. 그리고 DDL로 정의된 내용은 '메타데이터'가 되고 '시스템 카탈로그'에 저장되며 번역한 결과가 '데이터 사전'이라는 특별한 파일에 여러개의 테이블로서 저장되어 관리된다
    * 시스템 카탈로그 = 데이터 사전
    >  DB에 포함된 다양한 데이터객체(테이블,뷰,인덱스등)에대한 정보들을 유지,관리 하기 위한 시스템 DB이다. DB에 포함되는 모든 데이터 객체에 대한 정의나 명세에 관한 정보를 유지 관리하고, DBMS가 스스로 생성하고 유지되는 DB 내의 특별한 테이블 집합체이다. 데이터 사전이라고도 하며 시스템 카탈로그에 저장된 정보를 메타데이터 라고 한다. 
  * DDL의 명령어 종류엔 Create(정의), Alter(변경), Drop(삭제) 이렇게 3가지의 명령이 있다.
  1) Create : create는 스키마,도메인,뷰,테이블,인덱스 등을 '정의'하는 명령어 이다.
     + DB에서 도메인이란? -> 릴레이션에 포함된 각각의 속성들이 가질 수 있는 값들의 집합이라고 할 수 있다. 도메인이라는 개념이 필요한 이유는 릴레이션에 저장되는 데이터 값들이 본래 의도했던 값들만 저장되고 관리하기 위해서다.
    1) Domain 정의 : 

## JOIN이란
> 관계형 DB에선 중복 데이터를 피하기 위해 데이터의 속성을 분류해 여러 테이블로 나누어 놓는 '정규화' 작업을 한다. 이렇게 정규화된 데이터에서 원하는 결과를 도출하기 위해 여러 테이블을 조합할 필요성이 생기는데 이런경우 사용하는 명령어가 컬럼을 기준으로 행을 합쳐 가상의 테이블 처럼 만들어 결과를 보여주는 연산인 **JOIN** 이다.  
**조인의 대표적 종류**
 1) INNER JOIN
 2) OUTER JOIN
 3) SELF JOIN
 4) CROSS JOIN
 <img src = "https://t1.daumcdn.net/cfile/tistory/99473C435C0D1ECD07"/>
 
 ### 1. INNER JOIN(내부 조인)
 > INNER JOIN은 키 값이 있는 두 테이블의 컬럼 값을 비교한후 조건에 맞는 값만을 가져오고 나머지는 버린다. 간단하게 말해 조건에 맞는 값들만 검색하는 조인 방식이다.
 <img src="https://t1.daumcdn.net/cfile/tistory/251A374456EB994D13"/>
 
 * SQL은 명시적 조인표현과 암시적 조인 표현으로 구분을 지정한다.
   1) 명시적 조인 표현
   > 테이블에 조인하라는 것을 지정하기 위해 'JOIN' 명령을 사용하고 ON의 키워드를 사용해 조인에 대한 조건을 걸어준다.
  
   ```
   select * from people as p inner join people_filmo as pf on p.peopleCd = pf.peopleCd
   // people은 영화 관련 인물들 테이블, people_filmo는 인물들과 관련되 영화에 대한 테이블(=movie와 people의 N:M관계에서 나온 테이블)
   ```
   2) 암시적 조인 표현
   > select구문의 from절에서 , 를 사용하여 단순히 조인을 위한 여러 테이블을 나열하면된다. 
   ```
   select * from people as p, people_filmo as pf where p.peopleCd = pf.peopleCd
   ```
   
  ### 2. CROSS JOIN(교차 조인)
  > CROSS JOIN은 카디션 곱 이라고도 하며 조인되는 두 테이블에서 곱집합을 반환한다... 즉 m열을 가진 테이블과 n열을 가진 테이블이 교차조인되면 m * n개의 열이 생성된다.
  => people 테이블에 '이병헌','황정민' 이있고 movie 테이블에 '국제시장','남산의 부장들' 이있다. 이병헌은 남산, 황정민은 국제시장만 연관되어있다. 이상황에서 교차 조인시 이병헌 | 국제시장,  이병헌 | 남산의 부장들 , 황정민 | 국제시장, 황정민 | 남산의 부장들  이렇게 조인이 된다 
  
  ### 3. OUTER JOIN(외부 조인)
  > Outer join 은 조인하는 여러 테이블에서 한쪽에는 데이터가 있고 한쪽에는 데이터가 없는 경우 데이터가 있는쪽 테이블의 내용을 전부 출력하는 방식이다. 즉 조인 조건에 만족하지않아도 해당 행을 출력하고 싶은 경우 사용할수 있다.
  * outer join에는 left,right,full outer join이 있다.
 
   #### 3-1 LEFT OUTER JOIN
   > LEFT OUTER JOIN은 조인문의 왼쪽에 있는 테이블의 모든 결과를 가져온후 오른쪽 테이블의 데이터를 매칭하고, 매칭되는 데이터가 없는 경우 NULL을 표기해준다.
   <img src="https://t1.daumcdn.net/cfile/tistory/224EFA4656EF49B309"/>
   
   ```
   select * from people as p left (outer 생략가능) join people_filmo as pf on p.peopleCd = pf.peopleCd;
   //people 테이블에서 활동내역이 없으면 filmo테이블에 없지만 left join시 활동내역없는 people데이터도 출력되며 filmo와 관련된 컬럼에는 null로 출력되게 된다.
   ```
   
   #### 3-2 RIGHT OUTER JOIN
   > RIGHT OUTER JOIN은 조인문의 오른쪽에 있는 테이블의 모든 결과를 가져온후 왼쪽 테이블의 데이터를 매칭하고, 매칭되는 데이터가 없는 경우 NULL을 표기해준다.
   <img src="https://t1.daumcdn.net/cfile/tistory/2418A25056EF4BA912"/>
   
   ```
   select * from people as p right (outer 생략가능) join people_filmo as pf on p.peopleCd = pf.peopleCd;
   //people 테이블에서 활동내역이 없으면 filmo테이블에 없지만 right join시 people이 없는 people_filmo데이터도 출력되며 people와 관련된 컬럼에는 null로 출력되게 된다.(이건 테이블 구조상 예시가 조금 이상하긴 하지만 이해를 위한 예제이기에 감안했다.)
   ```
   #### 3-3 FULL OUTER JOIN
   > FULL OUTER JOIN은 LEFT OUTER JOIN과 RIGHT OUTER JOIN을 합친 것이다. mysql의 경우 Full outer join을 지원하지 않아 다른 방식으로 구현한다.(대표적 UNION 함수)
   <img src="https://t1.daumcdn.net/cfile/tistory/232EF54356EF4DA123"/>
   
   ```
   select * from people as p right (outer 생략가능) join people_filmo as pf on p.peopleCd = pf.peopleCd union select * from people as p left join people_filmo as pf on p.peopleCd = pf.peopleCd ;
   //연관없는 양쪽 테이블의 데이터들도 모두 가져온다.
   ```
 ### 4. SELF JOIN 
 > self join은 테이블에서 자기자신을 조인시키는 것이다.
 ```
 select * from people as p join people as sp on p.peopleCd = sp.peopleCd
 ```
